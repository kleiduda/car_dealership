{"ast":null,"code":"import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\nimport _classCallCheck from '@babel/runtime/helpers/esm/classCallCheck';\nimport _createClass from '@babel/runtime/helpers/esm/createClass';\nimport { throttle, debounce } from 'lodash-es';\nimport canUseDOM from 'can-use-dom';\nvar cachedScrollbarWidth = null;\nvar cachedDevicePixelRatio = null;\n\nif (canUseDOM) {\n  window.addEventListener('resize', function () {\n    if (cachedDevicePixelRatio !== window.devicePixelRatio) {\n      cachedDevicePixelRatio = window.devicePixelRatio;\n      cachedScrollbarWidth = null;\n    }\n  });\n}\n\nfunction scrollbarWidth() {\n  if (cachedScrollbarWidth === null) {\n    if (typeof document === 'undefined') {\n      cachedScrollbarWidth = 0;\n      return cachedScrollbarWidth;\n    }\n\n    var body = document.body;\n    var box = document.createElement('div');\n    box.classList.add('simplebar-hide-scrollbar');\n    body.appendChild(box);\n    var width = box.getBoundingClientRect().right;\n    body.removeChild(box);\n    cachedScrollbarWidth = width;\n  }\n\n  return cachedScrollbarWidth;\n}\n\nfunction getElementWindow(element) {\n  if (!element || !element.ownerDocument || !element.ownerDocument.defaultView) {\n    return window;\n  }\n\n  return element.ownerDocument.defaultView;\n}\n\nfunction getElementDocument(element) {\n  if (!element || !element.ownerDocument) {\n    return document;\n  }\n\n  return element.ownerDocument;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nvar SimpleBar = /*#__PURE__*/function () {\n  function SimpleBar(element) {\n    var _this = this;\n\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, SimpleBar);\n\n    this.onScroll = function () {\n      var elWindow = getElementWindow(_this.el);\n\n      if (!_this.scrollXTicking) {\n        elWindow.requestAnimationFrame(_this.scrollX);\n        _this.scrollXTicking = true;\n      }\n\n      if (!_this.scrollYTicking) {\n        elWindow.requestAnimationFrame(_this.scrollY);\n        _this.scrollYTicking = true;\n      }\n\n      if (!_this.isScrolling) {\n        _this.isScrolling = true;\n\n        _this.el.classList.add(_this.classNames.scrolling);\n      }\n\n      _this.onStopScrolling();\n    };\n\n    this.scrollX = function () {\n      if (_this.axis.x.isOverflowing) {\n        _this.positionScrollbar('x');\n      }\n\n      _this.scrollXTicking = false;\n    };\n\n    this.scrollY = function () {\n      if (_this.axis.y.isOverflowing) {\n        _this.positionScrollbar('y');\n      }\n\n      _this.scrollYTicking = false;\n    };\n\n    this.onStopScrolling = function () {\n      _this.el.classList.remove(_this.classNames.scrolling);\n\n      _this.isScrolling = false;\n    };\n\n    this.onMouseEnter = function () {\n      if (!_this.isMouseEntering) {\n        _this.el.classList.add(_this.classNames.mouseEntered);\n\n        _this.isMouseEntering = true;\n      }\n\n      _this.onMouseEntered();\n    };\n\n    this.onMouseEntered = function () {\n      _this.el.classList.remove(_this.classNames.mouseEntered);\n\n      _this.isMouseEntering = false;\n    };\n\n    this.onMouseMove = function (e) {\n      _this.mouseX = e.clientX;\n      _this.mouseY = e.clientY;\n\n      if (_this.axis.x.isOverflowing || _this.axis.x.forceVisible) {\n        _this.onMouseMoveForAxis('x');\n      }\n\n      if (_this.axis.y.isOverflowing || _this.axis.y.forceVisible) {\n        _this.onMouseMoveForAxis('y');\n      }\n    };\n\n    this.onMouseLeave = function () {\n      _this.onMouseMove.cancel();\n\n      if (_this.axis.x.isOverflowing || _this.axis.x.forceVisible) {\n        _this.onMouseLeaveForAxis('x');\n      }\n\n      if (_this.axis.y.isOverflowing || _this.axis.y.forceVisible) {\n        _this.onMouseLeaveForAxis('y');\n      }\n\n      _this.mouseX = -1;\n      _this.mouseY = -1;\n    };\n\n    this.onWindowResize = function () {\n      // Recalculate scrollbarWidth in case it's a zoom\n      _this.scrollbarWidth = SimpleBar.getScrollbarWidth();\n\n      _this.hideNativeScrollbar();\n    };\n\n    this.onPointerEvent = function (e) {\n      var isWithinTrackXBounds, isWithinTrackYBounds;\n      _this.axis.x.track.rect = _this.axis.x.track.el.getBoundingClientRect();\n      _this.axis.y.track.rect = _this.axis.y.track.el.getBoundingClientRect();\n\n      if (_this.axis.x.isOverflowing || _this.axis.x.forceVisible) {\n        isWithinTrackXBounds = _this.isWithinBounds(_this.axis.x.track.rect);\n      }\n\n      if (_this.axis.y.isOverflowing || _this.axis.y.forceVisible) {\n        isWithinTrackYBounds = _this.isWithinBounds(_this.axis.y.track.rect);\n      } // If any pointer event is called on the scrollbar\n\n\n      if (isWithinTrackXBounds || isWithinTrackYBounds) {\n        // Prevent event leaking\n        e.stopPropagation();\n\n        if (e.type === 'pointerdown' && e.pointerType !== 'touch') {\n          if (isWithinTrackXBounds) {\n            _this.axis.x.scrollbar.rect = _this.axis.x.scrollbar.el.getBoundingClientRect();\n\n            if (_this.isWithinBounds(_this.axis.x.scrollbar.rect)) {\n              _this.onDragStart(e, 'x');\n            } else {\n              _this.onTrackClick(e, 'x');\n            }\n          }\n\n          if (isWithinTrackYBounds) {\n            _this.axis.y.scrollbar.rect = _this.axis.y.scrollbar.el.getBoundingClientRect();\n\n            if (_this.isWithinBounds(_this.axis.y.scrollbar.rect)) {\n              _this.onDragStart(e, 'y');\n            } else {\n              _this.onTrackClick(e, 'y');\n            }\n          }\n        }\n      }\n    };\n\n    this.drag = function (e) {\n      var eventOffset;\n      var track = _this.axis[_this.draggedAxis].track;\n      var trackSize = track.rect[_this.axis[_this.draggedAxis].sizeAttr];\n      var scrollbar = _this.axis[_this.draggedAxis].scrollbar;\n      var contentSize = _this.contentWrapperEl[_this.axis[_this.draggedAxis].scrollSizeAttr];\n      var hostSize = parseInt(_this.elStyles[_this.axis[_this.draggedAxis].sizeAttr], 10);\n      e.preventDefault();\n      e.stopPropagation();\n\n      if (_this.draggedAxis === 'y') {\n        eventOffset = e.pageY;\n      } else {\n        eventOffset = e.pageX;\n      } // Calculate how far the user's mouse is from the top/left of the scrollbar (minus the dragOffset).\n\n\n      var dragPos = eventOffset - track.rect[_this.axis[_this.draggedAxis].offsetAttr] - _this.axis[_this.draggedAxis].dragOffset; // Convert the mouse position into a percentage of the scrollbar height/width.\n\n      var dragPerc = dragPos / (trackSize - scrollbar.size); // Scroll the content by the same percentage.\n\n      var scrollPos = dragPerc * (contentSize - hostSize); // Fix browsers inconsistency on RTL\n\n      if (_this.draggedAxis === 'x') {\n        scrollPos = _this.isRtl && SimpleBar.getRtlHelpers().isScrollOriginAtZero ? scrollPos - (trackSize + scrollbar.size) : scrollPos;\n      }\n\n      _this.contentWrapperEl[_this.axis[_this.draggedAxis].scrollOffsetAttr] = scrollPos;\n    };\n\n    this.onEndDrag = function (e) {\n      var elDocument = getElementDocument(_this.el);\n      var elWindow = getElementWindow(_this.el);\n      e.preventDefault();\n      e.stopPropagation();\n\n      _this.el.classList.remove(_this.classNames.dragging);\n\n      elDocument.removeEventListener('mousemove', _this.drag, true);\n      elDocument.removeEventListener('mouseup', _this.onEndDrag, true);\n      _this.removePreventClickId = elWindow.setTimeout(function () {\n        // Remove these asynchronously so we still suppress click events\n        // generated simultaneously with mouseup.\n        elDocument.removeEventListener('click', _this.preventClick, true);\n        elDocument.removeEventListener('dblclick', _this.preventClick, true);\n        _this.removePreventClickId = null;\n      });\n    };\n\n    this.preventClick = function (e) {\n      e.preventDefault();\n      e.stopPropagation();\n    };\n\n    this.el = element;\n    this.minScrollbarWidth = 20;\n    this.stopScrollDelay = 175;\n    this.options = _objectSpread(_objectSpread({}, SimpleBar.defaultOptions), options);\n    this.classNames = _objectSpread({\n      contentEl: 'simplebar-content',\n      contentWrapper: 'simplebar-content-wrapper',\n      offset: 'simplebar-offset',\n      mask: 'simplebar-mask',\n      wrapper: 'simplebar-wrapper',\n      placeholder: 'simplebar-placeholder',\n      scrollbar: 'simplebar-scrollbar',\n      track: 'simplebar-track',\n      heightAutoObserverWrapperEl: 'simplebar-height-auto-observer-wrapper',\n      heightAutoObserverEl: 'simplebar-height-auto-observer',\n      visible: 'simplebar-visible',\n      horizontal: 'simplebar-horizontal',\n      vertical: 'simplebar-vertical',\n      hover: 'simplebar-hover',\n      dragging: 'simplebar-dragging',\n      scrolling: 'simplebar-scrolling',\n      scrollable: 'simplebar-scrollable',\n      mouseEntered: 'simplebar-mouse-entered'\n    }, this.options.classNames);\n    this.axis = {\n      x: {\n        scrollOffsetAttr: 'scrollLeft',\n        sizeAttr: 'width',\n        scrollSizeAttr: 'scrollWidth',\n        offsetSizeAttr: 'offsetWidth',\n        offsetAttr: 'left',\n        overflowAttr: 'overflowX',\n        dragOffset: 0,\n        isOverflowing: true,\n        isVisible: false,\n        forceVisible: false,\n        track: {},\n        scrollbar: {}\n      },\n      y: {\n        scrollOffsetAttr: 'scrollTop',\n        sizeAttr: 'height',\n        scrollSizeAttr: 'scrollHeight',\n        offsetSizeAttr: 'offsetHeight',\n        offsetAttr: 'top',\n        overflowAttr: 'overflowY',\n        dragOffset: 0,\n        isOverflowing: true,\n        isVisible: false,\n        forceVisible: false,\n        track: {},\n        scrollbar: {}\n      }\n    };\n    this.removePreventClickId = null;\n    this.isScrolling = false;\n    this.isMouseEntering = false; // Don't re-instantiate over an existing one\n\n    if (SimpleBar.instances.has(this.el)) {\n      return;\n    }\n\n    if (options.classNames) {\n      console.warn('simplebar: classNames option is deprecated. Please override the styles with CSS instead.');\n    }\n\n    if (options.autoHide) {\n      console.warn(\"simplebar: autoHide option is deprecated. Please use CSS instead: '.simplebar-scrollbar::before { opacity: 0.5 };' for autoHide: false\");\n    }\n\n    this.onMouseMove = throttle(this.onMouseMove, 64);\n    this.onWindowResize = debounce(this.onWindowResize, 64, {\n      leading: true\n    });\n    this.onStopScrolling = debounce(this.onStopScrolling, this.stopScrollDelay);\n    this.onMouseEntered = debounce(this.onMouseEntered, this.stopScrollDelay);\n    this.init();\n  }\n  /**\n   * Static properties\n   */\n\n  /**\n   * Helper to fix browsers inconsistency on RTL:\n   *  - Firefox inverts the scrollbar initial position\n   *  - IE11 inverts both scrollbar position and scrolling offset\n   * Directly inspired by @KingSora's OverlayScrollbars https://github.com/KingSora/OverlayScrollbars/blob/master/js/OverlayScrollbars.js#L1634\n   */\n\n\n  _createClass(SimpleBar, [{\n    key: \"init\",\n    value: function init() {\n      // Save a reference to the instance, so we know this DOM node has already been instancied\n      SimpleBar.instances.set(this.el, this); // We stop here on server-side\n\n      if (canUseDOM) {\n        this.initDOM();\n        this.rtlHelpers = SimpleBar.getRtlHelpers();\n        this.scrollbarWidth = SimpleBar.getScrollbarWidth();\n        this.recalculate();\n        this.initListeners();\n      }\n    }\n  }, {\n    key: \"initDOM\",\n    value: function initDOM() {\n      var _this2 = this; // make sure this element doesn't have the elements yet\n\n\n      if (Array.prototype.filter.call(this.el.children, function (child) {\n        return child.classList.contains(_this2.classNames.wrapper);\n      }).length) {\n        // assume that element has his DOM already initiated\n        this.wrapperEl = this.el.querySelector(\".\".concat(this.classNames.wrapper));\n        this.contentWrapperEl = this.options.scrollableNode || this.el.querySelector(\".\".concat(this.classNames.contentWrapper));\n        this.contentEl = this.options.contentNode || this.el.querySelector(\".\".concat(this.classNames.contentEl));\n        this.offsetEl = this.el.querySelector(\".\".concat(this.classNames.offset));\n        this.maskEl = this.el.querySelector(\".\".concat(this.classNames.mask));\n        this.placeholderEl = this.findChild(this.wrapperEl, \".\".concat(this.classNames.placeholder));\n        this.heightAutoObserverWrapperEl = this.el.querySelector(\".\".concat(this.classNames.heightAutoObserverWrapperEl));\n        this.heightAutoObserverEl = this.el.querySelector(\".\".concat(this.classNames.heightAutoObserverEl));\n        this.axis.x.track.el = this.findChild(this.el, \".\".concat(this.classNames.track, \".\").concat(this.classNames.horizontal));\n        this.axis.y.track.el = this.findChild(this.el, \".\".concat(this.classNames.track, \".\").concat(this.classNames.vertical));\n      } else {\n        // Prepare DOM\n        this.wrapperEl = document.createElement('div');\n        this.contentWrapperEl = document.createElement('div');\n        this.offsetEl = document.createElement('div');\n        this.maskEl = document.createElement('div');\n        this.contentEl = document.createElement('div');\n        this.placeholderEl = document.createElement('div');\n        this.heightAutoObserverWrapperEl = document.createElement('div');\n        this.heightAutoObserverEl = document.createElement('div');\n        this.wrapperEl.classList.add(this.classNames.wrapper);\n        this.contentWrapperEl.classList.add(this.classNames.contentWrapper);\n        this.offsetEl.classList.add(this.classNames.offset);\n        this.maskEl.classList.add(this.classNames.mask);\n        this.contentEl.classList.add(this.classNames.contentEl);\n        this.placeholderEl.classList.add(this.classNames.placeholder);\n        this.heightAutoObserverWrapperEl.classList.add(this.classNames.heightAutoObserverWrapperEl);\n        this.heightAutoObserverEl.classList.add(this.classNames.heightAutoObserverEl);\n\n        while (this.el.firstChild) {\n          this.contentEl.appendChild(this.el.firstChild);\n        }\n\n        this.contentWrapperEl.appendChild(this.contentEl);\n        this.offsetEl.appendChild(this.contentWrapperEl);\n        this.maskEl.appendChild(this.offsetEl);\n        this.heightAutoObserverWrapperEl.appendChild(this.heightAutoObserverEl);\n        this.wrapperEl.appendChild(this.heightAutoObserverWrapperEl);\n        this.wrapperEl.appendChild(this.maskEl);\n        this.wrapperEl.appendChild(this.placeholderEl);\n        this.el.appendChild(this.wrapperEl);\n      }\n\n      if (!this.axis.x.track.el || !this.axis.y.track.el) {\n        var track = document.createElement('div');\n        var scrollbar = document.createElement('div');\n        track.classList.add(this.classNames.track);\n        scrollbar.classList.add(this.classNames.scrollbar);\n        track.appendChild(scrollbar);\n        this.axis.x.track.el = track.cloneNode(true);\n        this.axis.x.track.el.classList.add(this.classNames.horizontal);\n        this.axis.y.track.el = track.cloneNode(true);\n        this.axis.y.track.el.classList.add(this.classNames.vertical);\n        this.el.appendChild(this.axis.x.track.el);\n        this.el.appendChild(this.axis.y.track.el);\n      }\n\n      this.axis.x.scrollbar.el = this.axis.x.track.el.querySelector(\".\".concat(this.classNames.scrollbar));\n      this.axis.y.scrollbar.el = this.axis.y.track.el.querySelector(\".\".concat(this.classNames.scrollbar));\n\n      if (!this.options.autoHide) {\n        this.axis.x.scrollbar.el.classList.add(this.classNames.visible);\n        this.axis.y.scrollbar.el.classList.add(this.classNames.visible);\n      }\n\n      this.el.setAttribute('data-simplebar', 'init');\n    }\n  }, {\n    key: \"initListeners\",\n    value: function initListeners() {\n      var _this3 = this;\n\n      var elWindow = getElementWindow(this.el); // Event listeners\n\n      this.el.addEventListener('mouseenter', this.onMouseEnter);\n      this.el.addEventListener('pointerdown', this.onPointerEvent, true);\n      this.el.addEventListener('mousemove', this.onMouseMove);\n      this.el.addEventListener('mouseleave', this.onMouseLeave);\n      this.contentWrapperEl.addEventListener('scroll', this.onScroll); // Browser zoom triggers a window resize\n\n      elWindow.addEventListener('resize', this.onWindowResize);\n\n      if (window.ResizeObserver) {\n        // Hack for https://github.com/WICG/ResizeObserver/issues/38\n        var resizeObserverStarted = false;\n        var resizeObserver = elWindow.ResizeObserver || ResizeObserver;\n        this.resizeObserver = new resizeObserver(function () {\n          if (!resizeObserverStarted) return;\n          elWindow.requestAnimationFrame(function () {\n            _this3.recalculate();\n          });\n        });\n        this.resizeObserver.observe(this.el);\n        this.resizeObserver.observe(this.contentEl);\n        elWindow.requestAnimationFrame(function () {\n          resizeObserverStarted = true;\n        });\n      } // This is required to detect horizontal scroll. Vertical scroll only needs the resizeObserver.\n\n\n      this.mutationObserver = new elWindow.MutationObserver(function () {\n        elWindow.requestAnimationFrame(function () {\n          _this3.recalculate();\n        });\n      });\n      this.mutationObserver.observe(this.contentEl, {\n        childList: true,\n        subtree: true,\n        characterData: true\n      });\n    }\n  }, {\n    key: \"recalculate\",\n    value: function recalculate() {\n      var elWindow = getElementWindow(this.el);\n      this.elStyles = elWindow.getComputedStyle(this.el);\n      this.isRtl = this.elStyles.direction === 'rtl';\n      var contentElOffsetWidth = this.contentEl.offsetWidth;\n      var isHeightAuto = this.heightAutoObserverEl.offsetHeight <= 1;\n      var isWidthAuto = this.heightAutoObserverEl.offsetWidth <= 1 || contentElOffsetWidth > 0;\n      var contentWrapperElOffsetWidth = this.contentWrapperEl.offsetWidth;\n      var elOverflowX = this.elStyles.overflowX;\n      var elOverflowY = this.elStyles.overflowY;\n      this.contentEl.style.padding = \"\".concat(this.elStyles.paddingTop, \" \").concat(this.elStyles.paddingRight, \" \").concat(this.elStyles.paddingBottom, \" \").concat(this.elStyles.paddingLeft);\n      this.wrapperEl.style.margin = \"-\".concat(this.elStyles.paddingTop, \" -\").concat(this.elStyles.paddingRight, \" -\").concat(this.elStyles.paddingBottom, \" -\").concat(this.elStyles.paddingLeft);\n      var contentElScrollHeight = this.contentEl.scrollHeight;\n      var contentElScrollWidth = this.contentEl.scrollWidth;\n      this.contentWrapperEl.style.height = isHeightAuto ? 'auto' : '100%'; // Determine placeholder size\n\n      this.placeholderEl.style.width = isWidthAuto ? \"\".concat(contentElOffsetWidth || contentElScrollWidth, \"px\") : 'auto';\n      this.placeholderEl.style.height = \"\".concat(contentElScrollHeight, \"px\");\n      var contentWrapperElOffsetHeight = this.contentWrapperEl.offsetHeight;\n      this.axis.x.isOverflowing = contentElOffsetWidth !== 0 && contentElScrollWidth > contentElOffsetWidth;\n      this.axis.y.isOverflowing = contentElScrollHeight > contentWrapperElOffsetHeight; // Set isOverflowing to false if user explicitely set hidden overflow\n\n      this.axis.x.isOverflowing = elOverflowX === 'hidden' ? false : this.axis.x.isOverflowing;\n      this.axis.y.isOverflowing = elOverflowY === 'hidden' ? false : this.axis.y.isOverflowing;\n      this.axis.x.forceVisible = this.options.forceVisible === 'x' || this.options.forceVisible === true;\n      this.axis.y.forceVisible = this.options.forceVisible === 'y' || this.options.forceVisible === true;\n      this.hideNativeScrollbar(); // Set isOverflowing to false if scrollbar is not necessary (content is shorter than offset)\n\n      var offsetForXScrollbar = this.axis.x.isOverflowing ? this.scrollbarWidth : 0;\n      var offsetForYScrollbar = this.axis.y.isOverflowing ? this.scrollbarWidth : 0;\n      this.axis.x.isOverflowing = this.axis.x.isOverflowing && contentElScrollWidth > contentWrapperElOffsetWidth - offsetForYScrollbar;\n      this.axis.y.isOverflowing = this.axis.y.isOverflowing && contentElScrollHeight > contentWrapperElOffsetHeight - offsetForXScrollbar;\n      this.axis.x.scrollbar.size = this.getScrollbarSize('x');\n      this.axis.y.scrollbar.size = this.getScrollbarSize('y');\n      this.axis.x.scrollbar.el.style.width = \"\".concat(this.axis.x.scrollbar.size, \"px\");\n      this.axis.y.scrollbar.el.style.height = \"\".concat(this.axis.y.scrollbar.size, \"px\");\n      this.positionScrollbar('x');\n      this.positionScrollbar('y');\n      this.toggleTrackVisibility('x');\n      this.toggleTrackVisibility('y');\n    }\n    /**\n     * Calculate scrollbar size\n     */\n\n  }, {\n    key: \"getScrollbarSize\",\n    value: function getScrollbarSize() {\n      var axis = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'y';\n\n      if (!this.axis[axis].isOverflowing) {\n        return 0;\n      }\n\n      var contentSize = this.contentEl[this.axis[axis].scrollSizeAttr];\n      var trackSize = this.axis[axis].track.el[this.axis[axis].offsetSizeAttr];\n      var scrollbarSize;\n      var scrollbarRatio = trackSize / contentSize; // Calculate new height/position of drag handle.\n\n      scrollbarSize = Math.max(~~(scrollbarRatio * trackSize), this.options.scrollbarMinSize);\n\n      if (this.options.scrollbarMaxSize) {\n        scrollbarSize = Math.min(scrollbarSize, this.options.scrollbarMaxSize);\n      }\n\n      return scrollbarSize;\n    }\n  }, {\n    key: \"positionScrollbar\",\n    value: function positionScrollbar() {\n      var axis = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'y';\n\n      if (!this.axis[axis].isOverflowing) {\n        return;\n      }\n\n      var contentSize = this.contentWrapperEl[this.axis[axis].scrollSizeAttr];\n      var trackSize = this.axis[axis].track.el[this.axis[axis].offsetSizeAttr];\n      var hostSize = parseInt(this.elStyles[this.axis[axis].sizeAttr], 10);\n      var scrollbar = this.axis[axis].scrollbar;\n      var scrollOffset = this.contentWrapperEl[this.axis[axis].scrollOffsetAttr];\n      scrollOffset = axis === 'x' && this.isRtl && SimpleBar.getRtlHelpers().isScrollOriginAtZero ? -scrollOffset : scrollOffset;\n      var scrollPourcent = scrollOffset / (contentSize - hostSize);\n      var handleOffset = ~~((trackSize - scrollbar.size) * scrollPourcent);\n      handleOffset = axis === 'x' && this.isRtl && SimpleBar.getRtlHelpers().isScrollingToNegative ? -handleOffset + (trackSize - scrollbar.size) : handleOffset;\n      scrollbar.el.style.transform = axis === 'x' ? \"translate3d(\".concat(handleOffset, \"px, 0, 0)\") : \"translate3d(0, \".concat(handleOffset, \"px, 0)\");\n    }\n  }, {\n    key: \"toggleTrackVisibility\",\n    value: function toggleTrackVisibility() {\n      var axis = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'y';\n      var track = this.axis[axis].track.el;\n      var scrollbar = this.axis[axis].scrollbar.el;\n\n      if (this.axis[axis].isOverflowing || this.axis[axis].forceVisible) {\n        track.style.visibility = 'visible';\n        this.contentWrapperEl.style[this.axis[axis].overflowAttr] = 'scroll';\n        this.el.classList.add(\"\".concat(this.classNames.scrollable, \"-\").concat(axis));\n      } else {\n        track.style.visibility = 'hidden';\n        this.contentWrapperEl.style[this.axis[axis].overflowAttr] = 'hidden';\n        this.el.classList.remove(\"\".concat(this.classNames.scrollable, \"-\").concat(axis));\n      } // Even if forceVisible is enabled, scrollbar itself should be hidden\n\n\n      if (this.axis[axis].isOverflowing) {\n        scrollbar.style.display = 'block';\n      } else {\n        scrollbar.style.display = 'none';\n      }\n    }\n  }, {\n    key: \"hideNativeScrollbar\",\n    value: function hideNativeScrollbar() {\n      this.offsetEl.style[this.isRtl ? 'left' : 'right'] = this.axis.y.isOverflowing || this.axis.y.forceVisible ? \"-\".concat(this.scrollbarWidth, \"px\") : 0;\n      this.offsetEl.style.bottom = this.axis.x.isOverflowing || this.axis.x.forceVisible ? \"-\".concat(this.scrollbarWidth, \"px\") : 0;\n    }\n    /**\n     * On scroll event handling\n     */\n\n  }, {\n    key: \"onMouseMoveForAxis\",\n    value: function onMouseMoveForAxis() {\n      var axis = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'y';\n      this.axis[axis].track.rect = this.axis[axis].track.el.getBoundingClientRect();\n      this.axis[axis].scrollbar.rect = this.axis[axis].scrollbar.el.getBoundingClientRect();\n      var isWithinScrollbarBoundsX = this.isWithinBounds(this.axis[axis].scrollbar.rect);\n\n      if (isWithinScrollbarBoundsX) {\n        this.axis[axis].scrollbar.el.classList.add(this.classNames.hover);\n      } else {\n        this.axis[axis].scrollbar.el.classList.remove(this.classNames.hover);\n      }\n\n      if (this.isWithinBounds(this.axis[axis].track.rect)) {\n        this.axis[axis].track.el.classList.add(this.classNames.hover);\n      } else {\n        this.axis[axis].track.el.classList.remove(this.classNames.hover);\n      }\n    }\n  }, {\n    key: \"onMouseLeaveForAxis\",\n    value: function onMouseLeaveForAxis() {\n      var axis = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'y';\n      this.axis[axis].track.el.classList.remove(this.classNames.hover);\n      this.axis[axis].scrollbar.el.classList.remove(this.classNames.hover);\n    }\n  }, {\n    key: \"onDragStart\",\n\n    /**\n     * on scrollbar handle drag movement starts\n     */\n    value: function onDragStart(e) {\n      var axis = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'y';\n      var elDocument = getElementDocument(this.el);\n      var elWindow = getElementWindow(this.el);\n      var scrollbar = this.axis[axis].scrollbar; // Measure how far the user's mouse is from the top of the scrollbar drag handle.\n\n      var eventOffset = axis === 'y' ? e.pageY : e.pageX;\n      this.axis[axis].dragOffset = eventOffset - scrollbar.rect[this.axis[axis].offsetAttr];\n      this.draggedAxis = axis;\n      this.el.classList.add(this.classNames.dragging);\n      elDocument.addEventListener('mousemove', this.drag, true);\n      elDocument.addEventListener('mouseup', this.onEndDrag, true);\n\n      if (this.removePreventClickId === null) {\n        elDocument.addEventListener('click', this.preventClick, true);\n        elDocument.addEventListener('dblclick', this.preventClick, true);\n      } else {\n        elWindow.clearTimeout(this.removePreventClickId);\n        this.removePreventClickId = null;\n      }\n    }\n    /**\n     * Drag scrollbar handle\n     */\n\n  }, {\n    key: \"onTrackClick\",\n    value: function onTrackClick(e) {\n      var _this4 = this;\n\n      var axis = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'y';\n      if (!this.options.clickOnTrack) return; // Preventing the event's default to trigger click underneath\n\n      e.preventDefault();\n      var elWindow = getElementWindow(this.el);\n      this.axis[axis].scrollbar.rect = this.axis[axis].scrollbar.el.getBoundingClientRect();\n      var scrollbar = this.axis[axis].scrollbar;\n      var scrollbarOffset = scrollbar.rect[this.axis[axis].offsetAttr];\n      var hostSize = parseInt(this.elStyles[this.axis[axis].sizeAttr], 10);\n      var scrolled = this.contentWrapperEl[this.axis[axis].scrollOffsetAttr];\n      var t = axis === 'y' ? this.mouseY - scrollbarOffset : this.mouseX - scrollbarOffset;\n      var dir = t < 0 ? -1 : 1;\n      var scrollSize = dir === -1 ? scrolled - hostSize : scrolled + hostSize;\n      var speed = 40;\n\n      var scrollTo = function scrollTo() {\n        if (dir === -1) {\n          if (scrolled > scrollSize) {\n            scrolled -= speed;\n            _this4.contentWrapperEl[_this4.axis[axis].scrollOffsetAttr] = scrolled;\n            elWindow.requestAnimationFrame(scrollTo);\n          }\n        } else {\n          if (scrolled < scrollSize) {\n            scrolled += speed;\n            _this4.contentWrapperEl[_this4.axis[axis].scrollOffsetAttr] = scrolled;\n            elWindow.requestAnimationFrame(scrollTo);\n          }\n        }\n      };\n\n      scrollTo();\n    }\n    /**\n     * Getter for content element\n     */\n\n  }, {\n    key: \"getContentElement\",\n    value: function getContentElement() {\n      return this.contentEl;\n    }\n    /**\n     * Getter for original scrolling element\n     */\n\n  }, {\n    key: \"getScrollElement\",\n    value: function getScrollElement() {\n      return this.contentWrapperEl;\n    }\n  }, {\n    key: \"removeListeners\",\n    value: function removeListeners() {\n      var elWindow = getElementWindow(this.el); // Event listeners\n\n      this.el.removeEventListener('mouseenter', this.onMouseEnter);\n      this.el.removeEventListener('pointerdown', this.onPointerEvent, true);\n      this.el.removeEventListener('mousemove', this.onMouseMove);\n      this.el.removeEventListener('mouseleave', this.onMouseLeave);\n\n      if (this.contentWrapperEl) {\n        this.contentWrapperEl.removeEventListener('scroll', this.onScroll);\n      }\n\n      elWindow.removeEventListener('resize', this.onWindowResize);\n\n      if (this.mutationObserver) {\n        this.mutationObserver.disconnect();\n      }\n\n      if (this.resizeObserver) {\n        this.resizeObserver.disconnect();\n      } // Cancel all debounced functions\n\n\n      this.onMouseMove.cancel();\n      this.onWindowResize.cancel();\n      this.onStopScrolling.cancel();\n      this.onMouseEntered.cancel();\n    }\n    /**\n     * UnMount mutation observer and delete SimpleBar instance from DOM element\n     */\n\n  }, {\n    key: \"unMount\",\n    value: function unMount() {\n      this.removeListeners();\n      SimpleBar.instances.delete(this.el);\n    }\n    /**\n     * Check if mouse is within bounds\n     */\n\n  }, {\n    key: \"isWithinBounds\",\n    value: function isWithinBounds(bbox) {\n      return this.mouseX >= bbox.left && this.mouseX <= bbox.left + bbox.width && this.mouseY >= bbox.top && this.mouseY <= bbox.top + bbox.height;\n    }\n    /**\n     * Find element children matches query\n     */\n\n  }, {\n    key: \"findChild\",\n    value: function findChild(el, query) {\n      var matches = el.matches || el.webkitMatchesSelector || el.mozMatchesSelector || el.msMatchesSelector;\n      return Array.prototype.filter.call(el.children, function (child) {\n        return matches.call(child, query);\n      })[0];\n    }\n  }], [{\n    key: \"getRtlHelpers\",\n    value: function getRtlHelpers() {\n      if (SimpleBar.rtlHelpers) {\n        return SimpleBar.rtlHelpers;\n      }\n\n      var dummyDiv = document.createElement('div');\n      dummyDiv.innerHTML = '<div class=\"simplebar-dummy-scrollbar-size\"><div></div></div>';\n      var scrollbarDummyEl = dummyDiv.firstElementChild;\n      var dummyChild = scrollbarDummyEl.firstElementChild;\n      document.body.appendChild(scrollbarDummyEl);\n      scrollbarDummyEl.scrollLeft = 0;\n      var dummyContainerOffset = SimpleBar.getOffset(scrollbarDummyEl);\n      var dummyChildOffset = SimpleBar.getOffset(dummyChild);\n      scrollbarDummyEl.scrollLeft = -999;\n      var dummyChildOffsetAfterScroll = SimpleBar.getOffset(dummyChild);\n      document.body.removeChild(scrollbarDummyEl);\n      SimpleBar.rtlHelpers = {\n        // determines if the scrolling is responding with negative values\n        isScrollOriginAtZero: dummyContainerOffset.left !== dummyChildOffset.left,\n        // determines if the origin scrollbar position is inverted or not (positioned on left or right)\n        isScrollingToNegative: dummyChildOffset.left !== dummyChildOffsetAfterScroll.left\n      };\n      return SimpleBar.rtlHelpers;\n    }\n  }, {\n    key: \"getScrollbarWidth\",\n    value: function getScrollbarWidth() {\n      // Try/catch for FF 56 throwing on undefined computedStyles\n      try {\n        // Detect browsers supporting CSS scrollbar styling and do not calculate\n        if (getComputedStyle(this.contentWrapperEl, '::-webkit-scrollbar').display === 'none' || 'scrollbarWidth' in document.documentElement.style || '-ms-overflow-style' in document.documentElement.style) {\n          return 0;\n        } else {\n          return scrollbarWidth();\n        }\n      } catch (e) {\n        return scrollbarWidth();\n      }\n    }\n  }, {\n    key: \"getOffset\",\n    value: function getOffset(el) {\n      var rect = el.getBoundingClientRect();\n      var elDocument = getElementDocument(el);\n      var elWindow = getElementWindow(el);\n      return {\n        top: rect.top + (elWindow.pageYOffset || elDocument.documentElement.scrollTop),\n        left: rect.left + (elWindow.pageXOffset || elDocument.documentElement.scrollLeft)\n      };\n    }\n  }]);\n\n  return SimpleBar;\n}();\n\nSimpleBar.defaultOptions = {\n  autoHide: true,\n  forceVisible: false,\n  clickOnTrack: true,\n  scrollbarMinSize: 25,\n  scrollbarMaxSize: 0\n};\nSimpleBar.instances = new WeakMap();\nexport default SimpleBar; //# sourceMappingURL=simplebar-core.esm.js.map","map":null,"metadata":{},"sourceType":"module"}